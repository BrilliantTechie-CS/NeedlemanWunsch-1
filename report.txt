Code Details
============

DNA Object
----------

The DNA object is relatively simple. Its only responsibility is to validate
and store a sequence of characters representing a piece of DNA. Inputting
data into the DNA object is done either when the object is constructed, by
passing a c-string representing the sequence to the constructor, or is done
using an overloaded operator>> function reading from cin (or any other istream
 object).

Validation of the data is done as soon as it is received. The validation
process is very simple - each character is checked, and if any is not a member
of the set [ACGT] then the sequence is invalid, and an exception is thrown that
contains information about where in the sequence the invalid character appeared.

Data from the DNA object is readable through the object's operator[] function.

DPM Object
----------

# Accomodating different data types

The DPM object is considerably more complex than the DNA object. Because the
data type that is used internally by the DPM object does not have any effect
on the public interface for getting the results of the algorithm, the
implementation details of the templated class were hidden as much as possible
from the end user of the DPM object. This was accomplished by wrapping all of
the business logic of the Needleman-Wunsch object in a seperate template class,
DPM_Implementation, which inherits from an abstract base class DPM_ImplementationBase.
The actual DPM object only keeps track of a pointer of the DPM_ImplementationBase
type that references an instance of the templated DPM_Implementation class. By
using one constructor that takes int parameters, and another that takes doubles,
the user of the class can pass whatever datatype they like, and not have to deal
with variables of multiple templated types.

# Traceback procedure

To optimize the traceback procedure, data about possible paths through
the matrix is stored during the filling of the matrix. Each cell of the matrix
is represent by a simple struct that contains the score for that position
in the matrix, and a set of flags indicating the cells which the current cell's
score could have originated from. This does not increase the space or time
complexity of the filling stage. The amount of space used increases from
(4 bytes * m * n) to (5 bytes * m * n), where m and n are the lengths of the
two sequences. Similarly, calculating the flags for each cell only adds a
constant amount of time to the calculations done for each cell, and the actual
time complexity does not change.

Since the direction information is already stored within the matrix, the
traceback procedure becomes a simple traversal of the acyclic directed
graph made up of the flags stored in the matrix. This traversal could easily
be done using a recursive function, but instead an stack-based implementation
was chosen. The reason for this was to make it possible to retrieve only a
limited number of possible alignments, to retrieve some, and then retrieve
more later on, or to retrieve all alignments using a lazy evaluation strategy,
which can provide a lot of memory savings.

To make the retrieval of alignments as convenient as possible, an STL compatible
iterator was created that makes it possible to easily retrieve results one at a
time. The iterator keeps a stack of nodes, which act as a bookmark for the current
position within the traceback procedure. Each time a new alignment is requested,
the iterator calls the _traceback() function of its parent DPM object, passing its
current stack. The stack is updated, and the next alignment is returned to the
iterator, overwriting the alignment that it stored previously.

In this program, the main advantage of this approach to calculating all
possible alignments is reduced space complexity. Rather than calculating all
alignments, storing them, and then looping over all of them, only one alignment
object is ever created at a time, allowing them to be looped over in constant
space. This is useful, because in many cases there are tens or hundreds of
thousands of possible alignments.

Time and Space Complexity
-------------------------

# traceback

The time complexity of the traceback procedure is different for retrieving
a single optimal alignment versus all possible alignments. For a single optimal
alignment, the maximum possible length is m+n, which would result from a situation
where there are no matches and gaps are inserted at all positions, for example:

AAAAAAAAA-------
---------GGGGGGG

In this case, the time complexity is O(m + n). The best case is that the length of
the optiaml alignment is the same as the lenght of the longest sequence to be aligned,
for example:

ATCGTAGCTCAGTACGTGACTG
AT--TAGC-CAG-----GA-TG

In this case, the time complexity is O(max(m,n)). In both cases, the time complexity is
roughly linear in m and n.

The time complexity for finding all optimal alignments is obviously greater than for
finding one optimal alignment. In this case a directed acyclic graph is implicitly
stored in the filled matrix (represented by the directional flags at each cell),
which makes finding all optimal aligments a simple depth-first traversal of the graph,
which has a worst-case time complexity of O(E + V) where E is the number of edges
in the graph and V is the number of vertices. In the worst case, every cell in the matrix
is a vertex, and every cell (other than those on the sides of the matrix) has three edges
leaving it (with the m + n edge cells having one edge each). This gives a total worst-case
time complexity of O((m+1)(n+1) + 3mn + m + n) = O(mn).

since the algorithm is a simple depth-first search, the time
complexity is O(|E| + |V|). The number of vertices is (m + 1)(n + 1), and
the number of edges is 3mn + m + n. Therefore the time complexity is O(mn).

Space complexity is at most 3(m + n) = O(m+n).

Initializing the matrix is O(mn)

Bugs
----

There are no known bugs in the program. Additionally, the program
has been tested using valgrind, and there are no memory leaks present.
